bomberman-dom/
├── client/
│   ├── index.html
│   ├── main.js                        # Entry point, initializes Main
│   ├── style.css
│   ├── framework/
│   │   ├── VDOMmanager.js            # VNode & VDOMManager class
│   │   └── utils.js                  # Helper functions (random, keys, etc.)
│   ├── core/
│   │   ├── Main.js                   # Main bootstrap logic
│   │   ├── GameManager.js            # Game loop, state, win condition
│   │   ├── SocketManager.js          # Client-side WebSocket handling
│   │   └── ChatManager.js            # Chat input and rendering
│   ├── game/
│   │   ├── Map.js                    # Game map grid
│   │   ├── Tile.js                   # Single tile representation
│   │   ├── Player.js                 # Player (local & remote)
│   │   ├── Bomb.js                   # Bomb object logic
│   │   ├── Explosion.js              # Explosion logic
│   │   ├── PowerUp.js                # Power-up logic
│   │   └── AIPlayer.js               # (Optional) AI behavior
│
├── server/
│   ├── server.js                     # Express server + WebSocket setup
│   ├── socketManager.js              # Server-side socket logic
│   └── gameState.js                  # (Optional) Global game state server-side
│
├── package.json
└── README.md


------------> state should be respected in frontend and backend

{
  players: {
    [id]: {
      x, y, lives, speed, bombs, flameLength, ...
    }
  },
  map: [...], // grid with walls, blocks, powerups
  bombs: [...], // {x, y, ownerId, timer}
}


🟢 Phase 1: Setup
 Create project folder structure
 Reuse/setup your custom mini DOM framework
 Create index.html, main.js, and server.js
 Set up static file server (Node.js + Express or similar)
 Set up WebSocket server (e.g. using ws)

🟡 Phase 2: Multiplayer Chat (WebSocket "Hello World")
 Prompt user for nickname on entry screen
 Connect to WebSocket server with nickname
 Display player count in lobby
 Implement chat input + message log
 Send/receive chat messages through WebSocket
 Broadcast messages to all clients

🔵 Phase 3: Lobby System
 Show number of players in lobby
 Start 10s countdown when 2–4 players connect
 Auto-start game after countdown
 Prevent players from joining after game starts

🔴 Phase 4: Core Game Engine
 Fixed-size grid map (e.g. 13x13)
 Add indestructible walls in fixed pattern
 Randomly place destructible blocks
 Reserve spawn zones in 4 corners
 Sync map between all clients via WebSocket

🟠 Phase 5: Player Mechanics
 Add 2–4 players at spawn corners
 Add keyboard movement (arrow/WASD)
 Prevent wall/block collision
 Display player DOM elements on map

🟣 Phase 6: Bomb Mechanics
 Allow dropping bombs with key press
 Bomb explodes after 3s
 Explosion affects blocks and players
 Add flame powerups (increase explosion range)
 Add bomb count powerups

🟤 Phase 7: Game Rules & Sync
 Add lives (3 per player)
 Respawn logic or death screen
 Broadcast full game state (positions, bombs, powerups)
 Keep server as single source of truth

⚫ Phase 8: Finishing Touches
 Add win condition (last player standing)
 Restart game option
 Optimize DOM updates and animations
 Maintain smooth 60fps with requestAnimationFrame

🟧 (Bonus) Optional Features
 Ghost after death mode
 Team mode (2v2)
 AI bot player(s)
 Extra powerups (Detonator, Bomb Pass, etc.)
 Powerup drops on death


 --->
 | Class                | Chosen Because...               |
| -------------------- | ------------------------------- |
| `Main`               | You need an app bootloader      |
| `Player`             | Each player has state and logic |
| `Map`, `Tile`        | Game grid management            |
| `Bomb`, `Explosion`  | Important game mechanics        |
| `PowerUp`            | Extendable feature              |
| `GameManager`        | Central loop and rules          |
| `SocketManager`      | Real-time sync                  |
| `ChatManager`        | Multiplayer communication       |
| `GameState` (server) | Keeps game state consistent     |

---> 
Main –the app, decides what to render (lobby or game).
Player – stores player state: position, speed, bombs, lives.
Map – builds and stores the 2D grid of the game world
Tile – represents one square on the grid (wall, block, empty).
Bomb – tracks location, owner, countdown, explosion range.
Explosion – handles flame spread and its effect on players and blocks.
PowerUp – stores power-up type and applies it to a player.
GameManager – coordinates all updates: movement, bomb logic, game end.
ChatManager – handles sending and displaying chat messages.
SocketManager (client) – manages WebSocket communication from browser to server.
SocketManager (server) – handles player connections and message broadcasting.
GameState (server) – stores global game data: players, bombs, map, scores



FUTURE VIEW : 

🟢 Game Boot (User opens game)
Main renders nickname input
On submission:
SocketManager (client) connects to the server
Sends: join event with nickname
Server:
SocketManager (server) registers player
GameState creates a new Player entry
Sends updated playerCount to all clients
If count >= 2 → start countdown
If 4 players → start game
 
🟡Game Start
Main switches to game screen
Map is rendered using Tile objects
Each Player is placed in a corner
GameManager:
Begins requestAnimationFrame loop
Updates all player movements
Handles bomb placement and countdowns

🔴 Real-Time Gameplay
Local user presses arrow key:
Player.move() updates local state
SocketManager sends move to server
Server:
Validates move
Broadcasts to others
All clients:
Receive move and update remote Player objects


💣 Bomb Placed
Local player presses bomb key:
Player.placeBomb() is called
GameManager adds a Bomb
SocketManager sends "bomb" event to server
Server:
Adds bomb to GameState
Broadcasts to all players
After timer:
Bomb.explode() is called
Explosion is triggered
Explosion.affectTiles() and .affectPlayers() modify state

🎁 PowerUps
A Tile hit by flame may spawn a PowerUp
If a player moves over it:
PowerUp.applyTo(player) is called
Player's speed/bombs/flames updated

⚰️ Player Dies
If caught in an explosion:
Player.loseLife()
If lives == 0 → remove from game
Server notifies clients
If only one remains → GameManager.checkWinCondition()

7. 📢 Chat Messaging
User types message
ChatManager.sendMessage() → SocketManager → server
Server:
SocketManager broadcasts message to all
All clients:
ChatManager.receiveMessage() displays it

8. 🏁 Game Ends
GameManager detects 1 player left
Broadcasts "Game Over"
Clients show result screen
Option to restart or leave

| Action                                                 | You use     |
| ------------------------------------------------------ | ----------- |
| 👉 Send a message **to the server**                    | `send()`    |
| 👂 Receive a message **from the server** and handle it | `trigger()` |
